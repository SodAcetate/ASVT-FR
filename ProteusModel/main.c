/* Main.c file generated by New Project wizard
 *
 * Created:   Сб дек 14 2024
 * Processor: PIC18LF66K80
 * Compiler:  CCS for PIC
 */

#include <18LF66K80.h>
#define USE_TX_ISR

#use delay(crystal=3.8MHz)

// Для общения с внутренними устройствами -- чековым принтером и ФН
#use rs232(UART1, baud=2400, stream=STR1)
// Для общения с POS-терминалом
#use rs232(UART2, baud=2400, stream=STR2)
  
// Значение на пинах B0-7
// B0 -- выбор устройства (0 -- ФН, 1 -- принтер)
char b;

// Массив тегов

char tags[][] = {
   "АВТОМАТ. РЕЖИМ",
   "АВТОНОМН. РЕЖИМ",
   "АДР. ОП. ПЕРЕВОДА",
   "ТЕЛ. ПОКУПАТЕЛЯ",
   "ЭЛ. АДР. ПОКУПАТЕЛЯ",
   "ЗН ККТ",
   "ИНН ОП. ПЕРЕВОДА",
   "ИНН ОФД",
   "ИНН",
   "ИТОГ",
   "КАССИР",
   "ОПЕРАТОР ПЕРЕВОДА",
   "НАЛИЧНЫМИ",
   "АВТОМАТ",
   "РН ККТ",
   "СМЕНА",
   "ФД",
   "ФН",
   "ЧЕК",
   "БСО",
   "ЧЕК КОР.",
   "БСО КОР.",
   "ОП. АГЕНТА",
   "ОФД",
   "РЕСУРС ФН МЕНЕЕ 30 ДНЕЙ",
   "РЕСУРС ФН МЕНЕЕ 3 ДНЕЙ",
   "ПАМЯТЬ ФН ЗАПОЛНЕНА",
   "ОФД НЕ ОТВЕЧАЕТ",
   "СНО",
   "ШФД",
   "САЙТ ФНС",	
   "СНО",
   "ТЛФ. ПЛ. АГЕНТА",
   "ТЛФ. ОП. ПР. ПЛАТЕЖА",
   "ТЛФ. ОП. ПЕРЕВОДА",
   "ФП",
   "БЕЗНАЛИЧНЫМИ",
   "НЕПЕРЕДАННЫХ ФД",
   "ФД НЕ ПЕРЕДАНЫ С",
   "ИЗМ. СВЕД. О ККТ",
   "СУММА НДС 20%",
   "СУММА НДС 10%",
   "СУММА С НДС 0%",
   "СУММА БЕЗ НДС",
   "СУММА НДС 20/120",
   "СУММА НДС 10/110",
   "ККТ ДЛЯ ИНТЕРНЕТ",
   "ККТ ДЛЯ УСЛУГ",
   "АС БСО",
   "ФД ЗА СМЕНУ",
   "ПЕРВЫЙ НЕПЕРЕДАННЫЙ ФД",
   "ЭЛ. АДР. ОТПРАВИТЕЛЯ",
   "ЧЕКОВ ЗА СМЕНУ",
   "БСО ЗА СМЕНУ",
   "ПРОВЕДЕНИЕ ЛОТЕРЕИ",
   "ЧЕКИ (БСО) КОРРЕКЦИИ",
   "ВСЕГО ЧЕКОВ",
   "ВСЕГО БСО",
   "КОЛ.ЧЕКОВ",
   "КОЛ.БСО",
   
   
};

// Вспомогательные функции ==========

// Поиск подстроки в строке длиной 40 байт

int find_substring(char string[], char substring[]){
       int j = 0;
       for (int i = 0; i < 20; i++) {
          if (string[i] == substring[j]) {
    	    j+=1;
          }
          else if (j>0) {
    	    j = 0;
          }
          if (substring[j] == '\0') {
    	    return i;
          }
       }
       return 0;
    }


// Байтовое представление числа

char* int_to_bytes(int n) {
   char* bytes;
   bytes = (char *) malloc(4);
   bytes[0] = (n >> 24) & 0xFF;
   bytes[1] = (n >> 16) & 0xFF;
   bytes[2] = (n >> 8) & 0xFF;
   bytes[3] = n & 0xFF;
   return bytes;
}

// Сформировать TLV

char* make_TLV(int tag, int length, char data[]) {
  char* bytes = (char*) malloc(40);
  //char* tag_bytes = (char*) malloc(4);
  char* tag_bytes = int_to_bytes(tag);
  for (int i = 0; i < 4; i++) {
      bytes[i] = tag_bytes[i];
  }
  free(tag_bytes);
  char* len_bytes = int_to_bytes(length);
  for (int i = 0; i < 4; i++) {
      bytes[i+4] = len_bytes[i];
  }
  free(len_bytes);
  for (int i = 0; i < length; i++) {
      bytes[i+8] = data[i];
  }
  return bytes;
}

// Поиск подстроки в строке длиной 40 байт

int find_substring(char string[], char substring[]){
       int j = 0;
       for (int i = 0; i < 20; i++) {
          if (string[i] == substring[j]) {
    	    j+=1;
          }
          else if (j>0) {
    	    j = 0;
          }
          if (substring[j] == '\0') {
    	    return i;
          }
       }
       return 0;
    }

// Настроить соединение с ФН
void select_storage() {
   b = b && 0xED;
   output_b(b);
}

// Настроить соединение с принтером
void select_printer() {
   b = b || 0x01;
   output_b(b);
}

// Функции регистратора =============

// 8Dh -- Открыть чек
void open_receipt() {
   // Пароль кассира -- 4 байта
   char  password[4];
   for (int i=0; i<4; i++){
      password[i] = getc(STR2);
   }
   // Тип документа -- 1 байт
   char doctype;
   doctype = getc(STR2);
   
   // Номер кассира
   char cashier_n = 0;
   
   // Включаем передачу данных на ФН
   select_storage();
   // Логика обмена данных с ФН не реализована
   char error = 0x00;
   
   // Формируем ответ
   putc(0x8d, STR2);
   putc(error, STR2);
   putc(cashier_n, STR2);
}

// 17h -- Печать строки
void print_and_feed_line() {
   // Пароль кассира -- 4 байта
   char  password[4];
   for (int i=0; i<4; i++){
      password[i] = getc(STR2);
   }
   // Флаги -- 1 байт
   char flag;
   flag = getc(STR2);
   // Символы строки -- 40 байт
   char line[40];
   for (int i=0; i<40; i++){
      line[i] = getc(STR2);
   }
   
   // Номер кассира
   char cashier_n = 0;
   
   // Включаем передачу данных на принтер
   select_printer();
   // Передаём данные в буфер принтера
   for (int i=0; i<40; i++) {
      if (line[i] == '\0') {
	 break;
      }
      putc(line[i], STR1);
   }
   // Передаём команду печати строки
   putc(0x1B, STR1);
   putc(0x4A, STR1);
   //putc('\n', STR1);
   
   // Включаем передачу данных на ФН
   select_storage();
   // Логика обмена данных с ФН не реализована
   char error = 0x00;
   
   // Формируем ответ
   putc(0x17, STR2);
   putc(error, STR2);
   //putc(cashier_n, STR2);
   
}

// 85h -- Закрыть чек
void close_receipt() {
   // Пароль кассира -- 4 байта
   char  password[4];
   for (int i=0; i<4; i++){
      password[i] = getc(STR2);
   }
   // Сумма наличных -- 5 байт
   char  sum_type_1[5];
   for (int i=0; i<5; i++){
      sum_type_1[i] = getc(STR2);
   }
   // Сумма типа оплаты 2 -- 5 байт
   char  sum_type_2[5];
   for (int i=0; i<5; i++){
      sum_type_2[i] = getc(STR2);
   }
   // Сумма типа оплаты 3 -- 5 байт
   char  sum_type_3[5];
   for (int i=0; i<5; i++){
      sum_type_3[i] = getc(STR2);
   }
   // Сумма типа оплаты 4 -- 5 байт
   char  sum_type_4[5];
   for (int i=0; i<5; i++){
      sum_type_4[i] = getc(STR2);
   }
   // Сумма скидки -- 2 байта
   char  discount[2];
   for (int i=0; i<2; i++){
      discount[i] = getc(STR2);
   }
   // Налог 1 -- 1 байт
   char tax_1;
   tax_1 = getc(STR2);
   // Налог 2 -- 1 байт
   char tax_2;
   tax_2 = getc(STR2);
   // Налог 3 -- 1 байт
   char tax_3;
   tax_3 = getc(STR2);
   // Налог 4 -- 1 байт
   char tax_4;
   tax_4 = getc(STR2);
   // Текст -- 40 байт
   char text[40];
   for (int i=0; i<40; i++){
      text[i] = getc(STR2);
   }
   
   // Номер кассира
   char cashier_n = 0;
   
   // Включаем передачу данных на ФН
   select_storage();
   // Логика обмена данных с ФН не реализована
   char error = 0x00;
   
   // Формируем ответ
   putc(0x85, STR2);
   putc(error, STR2);
   //putc(cashier_n, STR2);
}

// 25h -- Отрезать ленту
void cut() {
   // Пароль кассира -- 4 байта
   char  password[4];
   for (int i=0; i<4; i++){
      password[i] = getc(STR2);
   }
   // Тип отрезки -- 1 байт
   char cut_type;
   cut_type = getc(STR2);
   
   // Номер кассира
   char cashier_n = 0;
   
   // Включаем передачу данных на принтер
   select_printer();
   // Передаём команду отрезания ленты
   putc(0x1b, STR1);
   
   if (cut_type==0x00) {
      putc(0x6D, STR1);
   }
   else {
      putc(0x69, STR1);
   }
   
   char error = 0x00;
   
   // Формируем ответ
   putc(0x25, STR2);
   putc(error, STR2);
   //putc(cashier_n, STR2);
   
}

void main()
{
   set_tris_d(0);
   //setup_oscillator(OSC_8MHZ);
   //delay_ms(2000);
   char j;
   //printf("\r\nEX_RS232_BUFFER.c\r\n\n");
   
   enable_interrupts(GLOBAL);
   
   while(TRUE)
   {
      
     #ifndef USE_TX_ISR
      //putc_send();      //When not using the TXISR option with a HW UART
                        //this needs called often to cause data be moved
                        //from software buffer to HW transmit register.
                        //If using a software UART it also needs called to
                        //transmit data.
     #endif
      
   
       if(kbhit(STR2)) {
	 j = getc(STR2);
	 output_b(j);
	 if(j==0x17){
	    print_and_feed_line();
	 }
	 if(j==0x8d){
	    open_receipt();
	 }
	 if(j==0x85){
	    close_receipt();
	 }
	 if(j==0x25){
	    cut();
	 }
	}
	
   }
}
